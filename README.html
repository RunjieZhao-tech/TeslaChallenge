<!DOCTYPE html>
<html>
<head>
<title>README.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

</head>
<body>
<h1 id="autopilot-simulation-challenge">Autopilot Simulation Challenge</h1>
<p>Your objective is to construct a search algorithm to find the minimum time path through a hypothetical
network of Tesla supercharging stations. Your final route does not have to fully charge at every visited charger,
so long as it never runs out of charge between two chargers. You should expect to need no more
than 4-6 hours to solve this problem. We suggest implementing a quick brute force method before
attempting to find an optimal algorithm.</p>
<p>You may compare your solutions against our reference implementation using the provided
&quot;checker&quot; programs in either OSX (checker_osx), Windows Subsystem for Linux (checker_linux_64), or Linux (checker_linux_64). Make sure to use it to check your submission output
against several different start and end chargers.</p>
<hr>
<p>You will be provided with a csv which includes the charger network data
in the format below with newlines separating each charger:</p>
<pre><code>name, latitude in degrees, longitude in degrees
</code></pre>
<p>Your program should take as input three strings:</p>
<pre><code>	./your_solution [path to list of chargers csv] [start charger name] [end charger name]
</code></pre>
<p>Your program’s only output should be a print to standard out in the format:</p>
<pre><code>	initial charger name, first charger name, charge time in hrs, second charger name, charge time in hrs, …, …, goal charger name
</code></pre>
<p>This is the format required by the checker program as well, for example the command:</p>
<pre><code>	./your_solution network.csv Council_Bluffs_IA Cadillac_MI 
</code></pre>
<p>might return:</p>
<pre><code>	Council_Bluffs_IA, Worthington_MN, 0.17, Albert_Lea_MN, 0.33, Mauston_WI, 0.23, Sheboygan_WI, 0.24, Cadillac_MI
</code></pre>
<p>You can check the solution by providing your output to the included checker, for example:</p>
<pre><code>	./checker_osx network.csv &quot;Council_Bluffs_IA, Worthington_MN, 0.17, Albert_Lea_MN, 0.33, Mauston_WI, 0.23, Sheboygan_WI, 0.24, Cadillac_MI&quot;
</code></pre>
<p>will return:</p>
<pre><code>	Finding Path Between Council_Bluffs_IA and Cadillac_MI
	Reference result: Success, cost was 17.2531
	Candidate result: Success, cost was 17.2548
</code></pre>
<p>You should make the following assumptions:</p>
<ul>
<li>The car begins at the start charger with a full charge of 320km</li>
<li>The superchargers have a charge rate of 800km/hr</li>
<li>The car travels at a constant speed of 105km/hr along great circle routes between chargers</li>
<li>The Earth is a sphere of radius 6356.752km</li>
</ul>
<p>Your submission will be run against several start and end chargers and evaluated in terms of the
following metrics:</p>
<ul>
<li>Path satisfiability (car remains above 0km of range throughout entire trip)</li>
<li>Path optimality (total time driving + charging)</li>
<li>Coding structure</li>
<li>Code clarity</li>
<li>Computational cost</li>
</ul>
<p>You should ensure that your submission compiles under gcc with optimization level 1, for example:</p>
<pre><code>g++ -std=c++17 -O1 main.cpp network.cpp -o candidate_solution
</code></pre>
<p>Do not use libraries outside of the C++ Standard Library.</p>
<p>Feel free to add a README explaining your solution. If your solution includes additional cpp files include the appropriate compiler string in your README as well.</p>
<p>Runjie Zhao's Solution: In this problem, we first need to access csv file and retrieve the data from it. Then, we use the latitude/longitude distance formula to calculate the distance between two points. Then, we consider each place as a vertex and there is an edge between two vertices if and only if the distance between those two edges is less than 320. In that case, we can consider the distance between two vertices as the weights. Then, we can use Dijkstra's algorithm to calculate the shortest path from the source node to our destination node. Since the weight of each edge is not an integer, we are unable to use Dial's algorithm which is more efficient.</p>
</body>
</html>
